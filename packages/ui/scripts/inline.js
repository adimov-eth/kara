#!/usr/bin/env node
/**
 * Inline built Svelte bundles into worker view templates.
 * Uses esbuild to bundle all JS into a single module per view.
 */

import { readFileSync, writeFileSync, mkdirSync, existsSync, readdirSync } from 'fs';
import { join, dirname, basename } from 'path';
import { fileURLToPath } from 'url';
import { build } from 'esbuild';

const __dirname = dirname(fileURLToPath(import.meta.url));
const distDir = join(__dirname, '..', 'dist');
const outputDir = join(__dirname, '..', '..', '..', 'worker', 'src', 'views', 'generated');

// View mapping: route name -> output variable name
// Note: '' (root) is the guest view, 'shikashika' is the admin route (secret path)
const views = [
  { route: '', varName: 'GUEST_HTML', title: 'Karaoke Queue', outputName: 'guest' },
  { route: 'player', varName: 'PLAYER_HTML', title: 'Karaoke Player', outputName: 'player' },
  { route: 'shikashika', varName: 'ADMIN_HTML', title: 'Karaoke Admin', outputName: 'admin' },
];

function findFiles(dir, pattern) {
  const results = [];
  if (!existsSync(dir)) return results;

  const items = readdirSync(dir, { withFileTypes: true });
  for (const item of items) {
    const fullPath = join(dir, item.name);
    if (item.isDirectory()) {
      results.push(...findFiles(fullPath, pattern));
    } else if (pattern.test(item.name)) {
      results.push(fullPath);
    }
  }
  return results;
}

async function inlineView(view) {
  // SvelteKit static adapter outputs as route.html directly in dist
  // For root route (''), look for index.html
  let htmlPath = view.route === ''
    ? join(distDir, 'index.html')
    : join(distDir, `${view.route}.html`);

  // Fallback: check for route/index.html format
  if (!existsSync(htmlPath) && view.route !== '') {
    htmlPath = join(distDir, view.route, 'index.html');
  }

  if (!existsSync(htmlPath)) {
    console.error(`HTML file not found: ${htmlPath}`);
    return null;
  }

  const html = readFileSync(htmlPath, 'utf-8');

  // Collect all CSS files
  const cssFiles = findFiles(join(distDir, '_app', 'immutable', 'assets'), /\.css$/);
  const cssContents = cssFiles.map(f => readFileSync(f, 'utf-8')).join('\n');

  // Find the entry modules from the HTML
  // SvelteKit generates: import("./_app/immutable/entry/start.XXX.js")
  const startMatch = html.match(/import\("\.?\/?(_app\/immutable\/entry\/start\.[^"]+\.js)"\)/);
  const appMatch = html.match(/import\("\.?\/?(_app\/immutable\/entry\/app\.[^"]+\.js)"\)/);

  if (!startMatch || !appMatch) {
    console.error(`Could not find entry points in ${htmlPath}`);
    console.error('HTML excerpt:', html.substring(0, 500));
    return null;
  }

  const startPath = join(distDir, startMatch[1]);
  const appPath = join(distDir, appMatch[1]);

  // Create a temporary entry file that imports both and starts the app
  const entryCode = `
import * as kit from '${startPath}';
import * as app from '${appPath}';

const base = new URL(".", location).pathname.slice(0, -1);
globalThis.__sveltekit_ekxh2u = { base };

const element = document.querySelector('[data-sveltekit-preload-data]') || document.body.firstElementChild || document.body;
kit.start(app, element);
`;

  // Use esbuild to bundle everything
  const result = await build({
    stdin: {
      contents: entryCode,
      resolveDir: distDir,
      loader: 'js',
    },
    bundle: true,
    minify: true,
    format: 'esm',
    write: false,
    target: 'es2020',
    logLevel: 'warning',
  });

  const bundledJs = result.outputFiles[0].text;

  // Build final HTML
  const inlinedHtml = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;800&display=swap" rel="stylesheet" />
  <title>${view.title}</title>
  <style>${cssContents}</style>
</head>
<body data-sveltekit-preload-data="hover">
  <div style="display: contents"></div>
  <script type="module">${bundledJs}</script>
</body>
</html>`;

  return inlinedHtml;
}

async function main() {
  // Create output directory
  mkdirSync(outputDir, { recursive: true });

  const exports = [];

  for (const view of views) {
    console.log(`Processing ${view.route}...`);
    const html = await inlineView(view);

    if (html) {
      // Escape backticks and $ for template literal
      const escaped = html.replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/\$/g, '\\$');

      const output = `// Auto-generated by packages/ui/scripts/inline.js
// Do not edit directly

export const ${view.varName} = \`${escaped}\`;
`;

      const outputName = view.outputName || view.route;
      const outPath = join(outputDir, `${outputName}.ts`);
      writeFileSync(outPath, output);
      console.log(`  Wrote ${outPath}`);
      exports.push(`export { ${view.varName} } from './${outputName}.js';`);
    }
  }

  // Write index file
  const indexContent = `// Auto-generated by packages/ui/scripts/inline.js
// Do not edit directly

${exports.join('\n')}
`;
  writeFileSync(join(outputDir, 'index.ts'), indexContent);
  console.log(`Wrote ${join(outputDir, 'index.ts')}`);

  console.log('Done!');
}

main().catch(err => {
  console.error(err);
  process.exit(1);
});
